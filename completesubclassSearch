#Here is the final submission of the subclass search for Iterated Local Search
class Search(Schedule):
	#the counter defined here is for entering the rush hour and the non rush hour
	counter = 0
	def __init__(self, seconds, start_time):
		# every time  an object is created the global counter increases 
		# since there are 3 slots of non rush hours and 2 slots for rush hours 
		# counter value for the rush hours will be 2 and 4, for the non rush hours it ll be 1,3 and 5.
		Search.counter += 1
		self.seconds = seconds
		self.start_time= start_time
		# here we call the constructor of the parent class Schedule for initialize
		self.schedule = Schedule(seconds, start_time)		
	#get the initial list after permutation and randomizing the data and we will apply our algorithm to this list.
	def get_initial_condition(self, initial_List, size):
		permutated_data = initial_List[:]
		for index in range(size):
			shuffle_data = random.randrange(index,size)
			permutated_data[shuffle_data] = permutated_data[index]
			permutated_data[index] = permutated_data[shuffle_data]
		return permutated_data
	def Iterated_Local_Search(self):
		#get the initial constraint from the parent class and function 
		self.schedule.initial_constraints()
		#satisfy the initial conditions from the parent class and the satisfy function 
		self.schedule.satisfied(False)
		#call the parent class method display Initial satisfying all the conditions
		initial_List = self.schedule.display_Initial()
		iteration_number = len(initial_List)
		#best list will go through iterative improvement
		best_List = []
		best_List = self.get_initial_condition(initial_List,iteration_number)
		best_List = self.localSearch(best_List, initial_List, iteration_number) 
		#while (iteration_number> 0):
		#	candidate = best_List
		#	best_List = self.stochasticTwoOpt(candidate)
		#	iteration_number -=1
		
		print(best_List)
	#just to apply the stchastic two opt move actually if we increase it to k opt move k being a value greater than 2 
	# we might get better results finally. 
	def stochasticTwoOpt(self, permutated_data):
		result = permutated_data[:]
		size = len(result)
		p1, p2 = random.randrange(0,size), random.randrange(0,size)
		# do this so as not to overshoot tour boundaries
		exclude = set([p1])
		if p1 == 0:
			exclude.add(size-1)
		else:
			exclude.add(p1-1)
		if p1 == size-1:
			exclude.add(0)
		else:
			exclude.add(p1+1) 
		while p2 in exclude:
			p2 = random.randrange(0,size)
		# to ensure we always have p1<p2        
		if p2<p1:
			p1, p2 = p2, p1
		# now reverse the segment between p1 and p2   
		result[p1:p2] = reversed(result[p1:p2])
		return result
	# Here we will satisfy the constraints according to rush hour and non rush hour
	def acceptanceCriterion(self, best_List):
		if Search.counter == 1:
			best_List = self.Non_rush_hour(best_List)
		elif Search.counter == 2:
			best_List = self.rush_hour(best_List)
		elif Search.counter == 3:
			best_List = self.Non_rush_hour(best_List)
		elif Search.counter == 4:
			best_List = self.rush_hour(best_List)
		elif Search.counter == 5:
			best_List = self.Non_rush_hour(best_List)
		else:
			print("Error: Object not counted in proper manner.")
		return best_List
	# now perturbation for the list the one list that is closer to satisfying the initial conditions
	# is the optimized list.
	def perturbation(self, best_List, initial_List, candidate):
		#we consider 2 counters for the length of the set that has more number of equal
		counterbest = 0
		countercandidate = 0
		#my_best = set(best_List)
		#my_candidate = set(candidate)
		#my_initial = set(initial_List)
		my_best = [i for i, j in zip(best_List, initial_List) if i == j]
		my_candidate = [i for i, j in zip(candidate, initial_List) if i == j]
		#print(my_best)
		#print(my_candidate)
		counterbest = len(my_best)
		countercandidate = len(my_candidate)
		#print(counterbest)
		#print(countercandidate)
		if counterbest > countercandidate:
			return best_List
		else:
			return candidate
	def localSearch(self, best_List, initial_List,iterations):
		best_List = self.acceptanceCriterion(best_List)
		while iterations > 0:
			candidate = []
			candidate = self.stochasticTwoOpt(best_List)
			iterations -=1
		best_List = self.perturbation(best_List, initial_List, candidate)	
		return best_List
	#maximize the cars passing at Borsbergstrasse
	#hence maximize the occurrence of 2565 and 80 (i.e. 101000000101 and 000001010000) 
	def rush_hour(self, best):
		#replace all instances of 0 by 2565 or 80 preferably 2565
		seq = [2656, 80]
		if len(seq) > 0:
			best = [random.choice(seq) if x==0 else x for x in best]
		else:
			print("IndexError")
		return best
	#minimize the cars passing at Borsbergstrasse
	#minimize the occurence of 80 and 2565
	def Non_rush_hour(self, best):
		#replace all instances of 0 in the list by 160 or 1290
		seq = [160, 1290]
		if len(seq) > 0:
			best = [random.choice(seq) if x==0 else x for x in best]
		else:
			print("IndexError")
		return best
	def convert_to_binary(self, best):
		for i in range(len(best)):
			best_compiled = '{0:012b}'.format(best[i])
		return best_compiled

build_conflict_mask()
build_trambus_schedules()
pre_morning_rush  = Search(int(1.5 * 60 * 60), datetime.time( 6, 0, 0)) #  6:00 –  7:30
pre_morning_rush.Iterated_Local_Search()
morning_rush      = Search(int(2.0 * 60 * 60), datetime.time( 7, 30, 0)) #  7:30 –  9:30
morning_rush.Iterated_Local_Search()
day               = Search(int(7.5 * 60 * 60), datetime.time( 9, 30, 0)) #  9:30 – 17:00
day.Iterated_Local_Search()
evening_rush      = Search(int(2.0 * 60 * 60), datetime.time(17,  0, 0)) # 17:00 – 19:00
evening_rush.Iterated_Local_Search()
post_evening_rush = Search(int(2.0 * 60 * 60), datetime.time(19,  0, 0)) # 19:00 – 21:00
post_evening_rush.Iterated_Local_Search()
		
